import { describe, beforeAll, beforeEach, afterEach, afterAll, it, expect } from '@ohos/hypium';
import { DataManager, Transaction, Category, BalanceSummary } from '../../main/ets/services/DataManager';
import { BusinessError } from '@ohos/base';

export default function DataManagerTest() {
  let dataManager: DataManager;
  let testContext: Context;

  describe('DataManager Unit Tests', () => {
    
    beforeAll(async () => {
      // æµ‹è¯•å‰å‡†å¤‡
      dataManager = DataManager.getInstance();
      testContext = getContext(this);
      await dataManager.init(testContext);
    });

    beforeEach(async () => {
      // æ¯ä¸ªæµ‹è¯•å‰æ¸…ç©ºæ•°æ®
      const transactions: Transaction[] = [];
      await dataManager.saveTransactions(transactions);
    });

    afterEach(async () => {
      // æ¯ä¸ªæµ‹è¯•åæ¸…ç†
      const transactions: Transaction[] = [];
      await dataManager.saveTransactions(transactions);
    });

    afterAll(() => {
      // æµ‹è¯•å®Œæˆåæ¸…ç†
      console.info('DataManager tests completed');
    });

    // ==================== åŸºç¡€åŠŸèƒ½æµ‹è¯• ====================
    
    it('should initialize DataManager correctly', 0, () => {
      expect(dataManager).assertNotNull();
      expect(DataManager.getInstance()).assertEqual(dataManager);
    });

    it('should add a single transaction correctly', 0, async () => {
      const transaction: Transaction = {
        id: Date.now(),
        title: 'æµ‹è¯•åˆé¤',
        amount: 35,
        type: 'expense',
        date: '2026-02-03',
        category: 'é¤é¥®'
      };

      const success = await dataManager.addTransaction(transaction);
      expect(success).assertTrue();

      const transactions = await dataManager.getTransactions();
      expect(transactions.length).assertEqual(1);
      expect(transactions[0].title).assertEqual('æµ‹è¯•åˆé¤');
      expect(transactions[0].amount).assertEqual(35);
      expect(transactions[0].type).assertEqual('expense');
    });

    it('should add multiple transactions', 0, async () => {
      const transactions: Transaction[] = [
        { id: 1, title: 'æ—©é¤', amount: 15, type: 'expense', date: '2026-02-03', category: 'é¤é¥®' },
        { id: 2, title: 'åœ°é“', amount: 6, type: 'expense', date: '2026-02-03', category: 'äº¤é€š' },
        { id: 3, title: 'å·¥èµ„', amount: 5000, type: 'income', date: '2026-02-03', category: 'å·¥èµ„' }
      ];

      for (const t of transactions) {
        await dataManager.addTransaction(t);
      }

      const result = await dataManager.getTransactions();
      expect(result.length).assertEqual(3);
    });

    it('should update an existing transaction', 0, async () => {
      const transaction: Transaction = {
        id: 1,
        title: 'åŸåˆé¤',
        amount: 30,
        type: 'expense',
        date: '2026-02-03',
        category: 'é¤é¥®'
      };

      await dataManager.addTransaction(transaction);

      const updatedTransaction: Transaction = {
        id: 1,
        title: 'ä¿®æ”¹åçš„åˆé¤',
        amount: 35,
        type: 'expense',
        date: '2026-02-03',
        category: 'é¤é¥®'
      };

      const success = await dataManager.updateTransaction(updatedTransaction);
      expect(success).assertTrue();

      const transactions = await dataManager.getTransactions();
      expect(transactions[0].title).assertEqual('ä¿®æ”¹åçš„åˆé¤');
      expect(transactions[0].amount).assertEqual(35);
    });

    it('should not update non-existent transaction', 0, async () => {
      const nonExistentTransaction: Transaction = {
        id: 999,
        title: 'ä¸å­˜åœ¨çš„è®°å½•',
        amount: 100,
        type: 'expense',
        date: '2026-02-03',
        category: 'é¤é¥®'
      };

      const success = await dataManager.updateTransaction(nonExistentTransaction);
      expect(success).assertFalse();
    });

    it('should delete a transaction by id', 0, async () => {
      const transaction: Transaction = {
        id: 1,
        title: 'å¾…åˆ é™¤',
        amount: 50,
        type: 'expense',
        date: '2026-02-03',
        category: 'é¤é¥®'
      };

      await dataManager.addTransaction(transaction);
      let transactions = await dataManager.getTransactions();
      expect(transactions.length).assertEqual(1);

      const success = await dataManager.deleteTransaction(1);
      expect(success).assertTrue();

      transactions = await dataManager.getTransactions();
      expect(transactions.length).assertEqual(0);
    });

    it('should handle delete of non-existent id', 0, async () => {
      const success = await dataManager.deleteTransaction(999);
      expect(success).assertTrue(); // åˆ é™¤ä¸å­˜åœ¨çš„IDåº”è¿”å›trueï¼ˆæ— å‰¯ä½œç”¨ï¼‰
    });

    // ==================== ä½™é¢è®¡ç®—æµ‹è¯• ====================

    it('should calculate balance correctly for income only', 0, async () => {
      await dataManager.addTransaction({
        id: 1, title: 'å·¥èµ„', amount: 5000, type: 'income',
        date: '2026-02-03', category: 'å·¥èµ„'
      });

      const summary = await dataManager.calculateBalance();
      expect(summary.balance).assertEqual(5000);
      expect(summary.totalIncome).assertEqual(5000);
      expect(summary.totalExpense).assertEqual(0);
    });

    it('should calculate balance correctly for expense only', 0, async () => {
      await dataManager.addTransaction({
        id: 1, title: 'è´­ç‰©', amount: 200, type: 'expense',
        date: '2026-02-03', category: 'è´­ç‰©'
      });

      const summary = await dataManager.calculateBalance();
      expect(summary.balance).assertEqual(-200);
      expect(summary.totalIncome).assertEqual(0);
      expect(summary.totalExpense).assertEqual(200);
    });

    it('should calculate balance correctly for mixed transactions', 0, async () => {
      await dataManager.addTransaction({
        id: 1, title: 'å·¥èµ„', amount: 5000, type: 'income',
        date: '2026-02-03', category: 'å·¥èµ„'
      });
      await dataManager.addTransaction({
        id: 2, title: 'æˆ¿ç§Ÿ', amount: 2000, type: 'expense',
        date: '2026-02-03', category: 'ä½æˆ¿'
      });
      await dataManager.addTransaction({
        id: 3, title: 'é¤é¥®', amount: 500, type: 'expense',
        date: '2026-02-03', category: 'é¤é¥®'
      });

      const summary = await dataManager.calculateBalance();
      expect(summary.balance).assertEqual(2500);
      expect(summary.totalIncome).assertEqual(5000);
      expect(summary.totalExpense).assertEqual(2500);
    });

    it('should handle empty transactions for balance calculation', 0, async () => {
      const summary = await dataManager.calculateBalance();
      expect(summary.balance).assertEqual(0);
      expect(summary.totalIncome).assertEqual(0);
      expect(summary.totalExpense).assertEqual(0);
    });

    // ==================== åˆ†ç±»ç®¡ç†æµ‹è¯• ====================

    it('should return default categories', 0, async () => {
      const categories = await dataManager.getCategories();
      expect(categories.length).assertLarger(0);
      
      // æ£€æŸ¥æ˜¯å¦åŒ…å«æ”¯å‡ºåˆ†ç±»
      const expenseCategories = categories.filter(c => c.type === 'expense');
      expect(expenseCategories.length).assertLarger(0);
      
      // æ£€æŸ¥æ˜¯å¦åŒ…å«æ”¶å…¥åˆ†ç±»
      const incomeCategories = categories.filter(c => c.type === 'income');
      expect(incomeCategories.length).assertLarger(0);
    });

    it('should save and retrieve custom categories', 0, async () => {
      const customCategories: Category[] = [
        { name: 'è‡ªå®šä¹‰æ”¯å‡º', icon: 'ğŸ¯', type: 'expense' },
        { name: 'è‡ªå®šä¹‰æ”¶å…¥', icon: 'ğŸ’', type: 'income' }
      ];

      const success = await dataManager.saveCategories(customCategories);
      expect(success).assertTrue();

      const retrieved = await dataManager.getCategories();
      expect(retrieved.length).assertEqual(2);
      expect(retrieved[0].name).assertEqual('è‡ªå®šä¹‰æ”¯å‡º');
    });

    // ==================== è¾¹ç•Œæƒ…å†µæµ‹è¯• ====================

    it('should handle zero amount transaction', 0, async () => {
      const transaction: Transaction = {
        id: 1,
        title: 'é›¶é‡‘é¢æµ‹è¯•',
        amount: 0,
        type: 'expense',
        date: '2026-02-03',
        category: 'é¤é¥®'
      };

      const success = await dataManager.addTransaction(transaction);
      expect(success).assertTrue();

      const summary = await dataManager.calculateBalance();
      expect(summary.totalExpense).assertEqual(0);
    });

    it('should handle large amount transaction', 0, async () => {
      const transaction: Transaction = {
        id: 1,
        title: 'å¤§é¢äº¤æ˜“',
        amount: 999999.99,
        type: 'income',
        date: '2026-02-03',
        category: 'å·¥èµ„'
      };

      const success = await dataManager.addTransaction(transaction);
      expect(success).assertTrue();

      const summary = await dataManager.calculateBalance();
      expect(summary.totalIncome).assertEqual(999999.99);
    });

    it('should handle decimal amount correctly', 0, async () => {
      const transaction: Transaction = {
        id: 1,
        title: 'å°æ•°é‡‘é¢',
        amount: 35.5,
        type: 'expense',
        date: '2026-02-03',
        category: 'é¤é¥®'
      };

      await dataManager.addTransaction(transaction);
      const transactions = await dataManager.getTransactions();
      expect(transactions[0].amount).assertEqual(35.5);
    });

    it('should handle special characters in title', 0, async () => {
      const transaction: Transaction = {
        id: 1,
        title: 'ç‰¹æ®Šå­—ç¬¦æµ‹è¯•!@#$%^&*()',
        amount: 100,
        type: 'expense',
        date: '2026-02-03',
        category: 'é¤é¥®'
      };

      const success = await dataManager.addTransaction(transaction);
      expect(success).assertTrue();

      const transactions = await dataManager.getTransactions();
      expect(transactions[0].title).assertEqual('ç‰¹æ®Šå­—ç¬¦æµ‹è¯•!@#$%^&*()');
    });

    it('should maintain transaction order (newest first)', 0, async () => {
      const t1: Transaction = { id: 1, title: 'ç¬¬ä¸€æ¡', amount: 10, type: 'expense', date: '2026-02-01', category: 'é¤é¥®' };
      const t2: Transaction = { id: 2, title: 'ç¬¬äºŒæ¡', amount: 20, type: 'expense', date: '2026-02-02', category: 'é¤é¥®' };
      const t3: Transaction = { id: 3, title: 'ç¬¬ä¸‰æ¡', amount: 30, type: 'expense', date: '2026-02-03', category: 'é¤é¥®' };

      await dataManager.addTransaction(t1);
      await dataManager.addTransaction(t2);
      await dataManager.addTransaction(t3);

      const transactions = await dataManager.getTransactions();
      // éªŒè¯æœ€æ–°æ·»åŠ çš„åœ¨æœ€å‰é¢
      expect(transactions[0].id).assertEqual(3);
      expect(transactions[1].id).assertEqual(2);
      expect(transactions[2].id).assertEqual(1);
    });

    // ==================== æ•°æ®æŒä¹…åŒ–æµ‹è¯• ====================

    it('should persist data across sessions', 0, async () => {
      const transaction: Transaction = {
        id: 1,
        title: 'æŒä¹…åŒ–æµ‹è¯•',
        amount: 100,
        type: 'expense',
        date: '2026-02-03',
        category: 'é¤é¥®'
      };

      await dataManager.addTransaction(transaction);

      // æ¨¡æ‹Ÿé‡æ–°åˆå§‹åŒ–ï¼ˆå®é™…æµ‹è¯•ä¸­ä¼šä¿æŒåŒä¸€ä¸ªå®ä¾‹ï¼‰
      const transactions = await dataManager.getTransactions();
      expect(transactions.length).assertEqual(1);
      expect(transactions[0].title).assertEqual('æŒä¹…åŒ–æµ‹è¯•');
    });

    // ==================== æ€§èƒ½æµ‹è¯• ====================

    it('should handle 100 transactions efficiently', 0, async () => {
      const startTime = Date.now();

      for (let i = 0; i < 100; i++) {
        await dataManager.addTransaction({
          id: i,
          title: `æµ‹è¯•è®°å½•${i}`,
          amount: i * 10,
          type: i % 2 === 0 ? 'expense' : 'income',
          date: '2026-02-03',
          category: 'é¤é¥®'
        });
      }

      const endTime = Date.now();
      const duration = endTime - startTime;

      const transactions = await dataManager.getTransactions();
      expect(transactions.length).assertEqual(100);
      expect(duration).assertLess(5000); // åº”è¯¥åœ¨5ç§’å†…å®Œæˆ
    });

    it('should calculate balance quickly with many transactions', 0, async () => {
      // å…ˆæ·»åŠ å¤§é‡æ•°æ®
      for (let i = 0; i < 50; i++) {
        await dataManager.addTransaction({
          id: i,
          title: `è®°å½•${i}`,
          amount: 100,
          type: 'expense',
          date: '2026-02-03',
          category: 'é¤é¥®'
        });
      }

      const startTime = Date.now();
      const summary = await dataManager.calculateBalance();
      const endTime = Date.now();

      expect(summary.totalExpense).assertEqual(5000);
      expect(endTime - startTime).assertLess(1000); // 1ç§’å†…å®Œæˆ
    });
  });
}
